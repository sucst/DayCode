设计模式的目的
编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好

代码重用性 (即：相同功能的代码，不用多次编写)

可读性 (即：编程规范性, 便于其他程序员的阅读和理解)

可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)

可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)

使程序呈现高内聚，低耦合的特性分享金句：

设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”

Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤

设计模式的七大原则
单一职责原则
单一职责的特点

对于这个原则书上是这样说的：对于一个类而言，应该仅有一个引起它变化的原因。换个通俗的语言来说，就是一个类只做自己的分内之事。就拿mvc分成来说的，view就是负责显示数据，model层负责封装数据，control层负责跟视图层跟model层交互。这也是在软件设计中为什么提倡mvc模式。如果不分层把所有代码写在一个类中，到时维护起来会有多么麻烦。这就是单一职责模型的最好的诠释了。 其实在软件设计中，大部分都在做一件事就是划分职责。最重要的也最难的就是划分职责。

开放封闭原则
开放封闭的特点

这个原则其实有两个特征，对扩展开放，对修改封闭的。 所以在程序中对于程序的设计要思考清楚，如果每次增加新功能都需要去修改原有的代码，那么便不符合，开放封闭原则。在程序中有新功能就新增代码，而不是修改原有的代码。这就是开放封闭的灵魂。

开放封闭原则的优点:

可维护
可扩展
可复用
灵活性好
![img.png](img.png)当然要拒绝不成熟的抽象，并不是每个都去抽象它。

依赖倒置原则
依赖倒置的特点

官方是这样解释的：抽象不应该依赖细节，细节依赖于抽象。换做通俗的话来说就是面向接口编程。

依赖倒置原则： 1.高层模块不应该依赖于低层模块。两个都要依赖于抽象。 2.抽象不应该依赖于细节，细节依赖于抽象。

​ 简单来说，就是你高层的代码，不应该依赖于底层的代码。应该依赖抽象接口或者类。不管需求怎么改。我们只需要修改具体的实现细节就行了。这就好比修电脑，内存条坏了换内存条就行，不应该说是把主板也换了。

里氏代换原则
里式代换的特点

官方是这样解释的：子类型必须能够完全替代父类型。这是继承的原则简单来说就是父类的东西子类必须有，在面向对象的设计中比如父类有个飞的方法，但是子类是个不能飞的东西（尽量不重写父类方法）。这就违反了这个原则！！！

再看依赖倒置原则

正是由于子类的可替换性，才使得不用修改父类模块的情况下就可以扩展。如果不依赖于这个原则，那谈什么开源-封闭。

这时候我们再来看看依赖倒置，不管是高层还是低层都依赖于抽象。看完这个应该更能理解依赖倒置原则了吧。如果代码不符合里式代换原则那么依赖倒置也是白谈了。所以依赖倒置大家谁都不依赖谁，除了约定接口外，自由发挥。

合成复用原则
合成复用的特点

这个原则的本质就是不要过多的依赖继承，尽量使用合成（合成是一种强拥有关系，表示部门与整体之间的关系。）或者聚合（聚合是一种弱拥有关系，可以这么理解就是a对象可以包含b对象但是b对象只是a对象的一部分。）

为什么使用合成复用原则

假设目前正在做一个数据库的连接功能，需要支持多种数据库，这时大家的想法肯定都是写一个操作类，然后具体实现类继承这个方法。这个思路是对的。但并不是继承就一定好，如果有一天万不得以，我需要修改的类的一个方法。这时是不是所有的实现类都需要去修改。这就有点牵一发而动全身。但是如果使用的是合成复用原则就不一样了。不管怎么改，我的实现类都是不需要去修改的。这样做其实也是解耦的一种方法。在程序中要遵循这个原则尽量少与人联系，以免遭到无妄之灾。

迪米特原则
迪米特的特点

官方解释：如果两个类不必彼此直接通信，那么两个类就不应该发生直接的相互作用。如果其中一个类调用其中的一个方法的话，应该通过第三者来转发。

为什么使用迪米特原则

在类的设计上，不必让第三者知道的字段或者方法封装好。迪米特原则的根本思想就是强调类之间的松耦合。类之间的耦合越弱越利于复用。一个弱耦合的类被修改，也不会对别的类造成波及。

接口隔离原则
这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

如果对于这个六个原则理解已经很深了，那么你的代码质量应该是非常高的了。

23个设计模式（GoF23）
总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。